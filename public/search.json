[{"title":"STM32F429 HAL库硬件IIC操作HDC1080记录","url":"/2025/09/10/STM32F429%20HAL%E5%BA%93%E7%A1%AC%E4%BB%B6IIC%E6%93%8D%E4%BD%9CHDC1080%E8%AE%B0%E5%BD%95/","content":" 器件类型\nHDC1080是14bit采样分辨率的温湿度传感器，通过IIC通信\n\n 硬件连线\n\n 引脚介绍\nHDC1080的引脚非常简单，只需要控制IIC的时钟和数据就好了。\n\n 软件编程\nHDC1080中有如下寄存器\n\n其中config寄存器，用来进行各种读取操作的配置，如下所示：\n\n要同时读取温度和湿度，需要配置寄存器第12位为1要设置读取分辨率为14位，需要设置[10:8]都为0。\n因此config寄存器中的值应该为0x1000，不过不用额外设置，该寄存器默认就是该值。\n如果没有其他要求，HDC1080使用默认配置就很好，接下来直接配置硬件IIC，也保持默认配置即可。\n\n对读取到的数据进行转化：\n\n\n 软件代码\n#define HDC1080_ADDR_R 0x81 // 1000 0001 高七位代表器件地址，最低为为读命令#define HDC1080_ADDR_W 0x80 // 1000 0000 写命令#define TEMPER_REG_ADDR 0x00#define HUMIDITY_REG_ADDR 0x01#define CONFIG_REG_ADDR 0x02#define MENUFACTURE_ID_REG_ADDR 0xfe#define DEVICE_ID_REG_ADDR 0xff#define CONFIG_REG_VALUE 0x1000 // 配置寄存器设为0x1000，表示获取温度和湿度，精度都为14bit，发送时只发送高八位，低八位固定为0typedef struct Temp_Humi_Value_t&#123;    float temperature; // 温度值    float humidity;    // 湿度值&#125; TH_Value_t;/** * @brief 获取HDC1080的设备ID * @return uint16_t 设备ID * @retval 0x1050 */uint16_t HDC1080_Get_DeviceID()&#123;    uint8_t buf[2];    HAL_I2C_Mem_Read(&amp;hi2c1, HDC1080_ADDR_R, DEVICE_ID_REG_ADDR, I2C_MEMADD_SIZE_8BIT, buf, sizeof(buf), 1000);    return (buf[0] &lt;&lt; 8) | buf[1];&#125;/** * @brief 设置HDC1080的配置寄存器 * @param Reg_value 配置寄存器值 * @retval None * @note 配置寄存器值为0x1000，表示获取温度和湿度，精度都为14bit，发送时只发送高八位，低八位固定为0*/void HDC1080_Set_ConfigReg(uint16_t Reg_value)&#123;    uint8_t buf[2];    /*寄存器值存储在高八位，低八位固定为0,但根据时序要求,还是要把低八位也发送出去*/    buf[0] = (Reg_value &gt;&gt; 8) &amp; 0xFF;    buf[1] = Reg_value &amp; 0xFF;    HAL_I2C_Mem_Write(&amp;hi2c1, HDC1080_ADDR_W, CONFIG_REG_ADDR, I2C_MEMADD_SIZE_8BIT, buf, sizeof(buf), 1000);&#125;/** * @brief 获取HDC1080的温度和湿度值 * @param temper 温度值指针 * @param humi 湿度值指针 * @retval None * @note 温度和湿度值的单位分别为摄氏度和百分比 */TH_Value_t HDC1080_Get_THvalue(void)&#123;    uint8_t buf[4];    uint8_t reg_addr = TEMPER_REG_ADDR;    TH_Value_t th_value;    // 第一步：发送要读取的寄存器地址（温度寄存器）    // 这会触发HDC1080开始进行温湿度转换    HAL_I2C_Master_Transmit(&amp;hi2c1, HDC1080_ADDR_W, &amp;reg_addr, 1, 1000);    // 等待转换完成，参考软件I2C的延迟时间    // HDC1080在最高分辨率下转换时间约为15ms    HAL_Delay(15);    // 第二步：读取转换后的4字节数据（温度2字节 + 湿度2字节）    HAL_I2C_Master_Receive(&amp;hi2c1, HDC1080_ADDR_R, buf, sizeof(buf), 1000);    // 温度计算    uint16_t temp_raw = (buf[0] &lt;&lt; 8) | buf[1];    th_value.temperature = (float)((temp_raw * 165.0 / 65536.0)- 40.0); // 转换为摄氏度    // 湿度计算    uint16_t humi_raw = (buf[2] &lt;&lt; 8) | buf[3];    th_value.humidity = (float)(humi_raw * 100.0 / 65536.0);    return th_value; // 返回温度和湿度值&#125;\n 注意事项\nHDC1080对湿度进行转换需要一定的时间，在发出读命令后不要立即接收，需要等待较长的一段时间，此处延迟15ms。\nHal库中有一个HAL_I2C_Mem_Read()函数\n函数原型：\nHAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout);\n该函数作用是直接读取对应器件中的寄存器值，其中包含了IIC读取寄存器的一次收发的完整时序。\n但该函数在操作HDC1080时不可用，因为其中没有足够的延时，不能读取到正确的值。\n","categories":["嵌入式","单片机","STM32"],"tags":["IIC","stm32","HAL库"]},{"title":"STM32F429 HAL库硬件IIC操作AD7606记录","url":"/2025/09/10/STM32F429%20HAL%E5%BA%93%E7%A1%AC%E4%BB%B6SPI%E6%93%8D%E4%BD%9CAD7606%E8%AE%B0%E5%BD%95/","content":" 分类介绍\nAD7606是用于监测电压的ADC，16位，采样率200ksps。根据通道数可以分为3类\n1.AD7606：可以接收8路电压输入\n\n2.AD7606-6：可以接收6路电压输入\n\n3.AD7606-4：接收4路电压输入\n\n 硬件接线\n\n 引脚介绍\n convstA和convstB\n类型：数字输入引脚，\n功能：AD7606可以接收多路电压输入，所有的电压输入被分为A和B两组，这两个引脚可以接收来自mcu的电平信号用于控制何时开始对应组的电压转换。\n正常状态下向该引脚输入高电平，然后拉低一段时间后重新拉高表示开始转换。只需要保持极短时间的低电平即可，实测168MHz的f429在两次电平切换语句中不必延时。\n这两个引脚还用于控制数据输出引脚（此处只介绍串行数据输出）[[#DOUTA和 DOUTB]]。\n若分别单独拉低covA和covB，中间间隔一段时间，则数据分别从DoutA，DoutB输出。这种情况就需要两个引脚来接受数据。\n可以在电路设计时将covA和covB连接在一起，电平同时变化，此时，所有通道的数据会从DoutA引脚输出。这样，就可以使用标准的SPI引脚的MOSI连接DoutA，在后续编程中可以很方便的使用SPI。\n PAR/SER/BYTE SEL\n类型：数字输入引脚\n功能：用于选择数据的串并行输出\n一般选串行输出（能用SPI），直接接高电平即可。\n BUSY\n类型：数字输出引脚\n功能：MCU可以接收来自该引脚的数据，高电平表示AD处于busy状态正在进行转换。\n可将该引脚接入MCU的一个IO，并设置为外部中断，下降沿触发。当中断发生，表明数据转完成，下一步就可以读数据进行处理了。\nAD7606可以在采集时读数，也就是中断设为上升沿触发，按道理说采集时读出的数据应该是无效的，不知道这样设计有什么意义，但我没有实际测试过。\n完整的一次通信过程（并行）：\n\n并行和串行只是SPI时序不同，触发SPI之前的时序是一样的。\n RANGE\n类型：数字输入引脚\n功能：模拟输入范围选择。\n逻辑输入引脚。该引脚上的极性决定了模拟输入通道的输入范围。\n连接到逻辑高电平，则所有通道的模拟输入范围为±10 V。\n连接到逻辑低电平，则所有通道的模拟输入范围为±5 V。\n该引脚上的逻辑变化会立即影响模拟输入范围。对于快速吞吐率应用，不建议在转换期间更改此引脚。\n FRSTDATA\n类型：数字输出引脚\nFRSTDATA输出信号指示第一个通道V1何时在并行、字节或串行接口上被输出。当CS输入为高电平时，FRSTDATA输出引脚处于三态。CS的下降沿使FRSTDATA脱离三态。\n在并行模式下，与V1结果对应的RD下降沿会将FRSTDATA引脚置为高电平，表明V1的结果在输出数据总线上可用。FRSTDATA输出在RD的下一个下降沿后返回逻辑低电平。\n在串行模式下，FRSTDATA在CS的下降沿变为高电平，因为这会将V1的最高有效位（MSB）通过DOUTA时钟输出。它在CS下降沿后的第16个SCLK下降沿返回低电平。\n DOUTA和 DOUTB\n类型：数字输出引脚\n功能：串行输出采集的数据\n对于AD7606，从通道V1到通道V4的转换结果首先出现在DOUTA上，从通道V5到通道V8的转换结果首先出现在DOUTB上。\n对于AD7606-6，从通道V1到通道V3的转换结果首先出现在DOUTA上，从通道V4到通道V6的转换结果首先出现在DOUTB上。\n对于AD7606-4，通道V1和通道V2的转换结果首先出现在DOUTA上，通道V3和通道V4的转换结果首先出现在DOUTB上。\n CS和SCLK\n时钟和片选和SPI同理\n配置时：CPHA=1，CPOL=1\n数据手册显示，支持的SPI最高通信速率为23.5MHz，但没必要跑这么快。\n\ncubeMX中配置如下所示，实测可以跑通\n\n器件的SPI通信时序\n\n OS0、OS1和OS2\n类型：数字输入引脚\n功能：控制AD7606的数字滤波器的过采样率\n\nOS引脚在BUSY下降沿锁存，在此之前设置好即可。\n 软件编程\n由于使用硬件SPI接受很简单，只需要在HAL库中点点就好了，如果不会看一下别人的教程，所以重点在如何触发SPI。\n 基本思路\n1.拉低convst引脚，触发转换，7606会自动开始转换，同时拉高busy引脚\n2.等待busy下降沿触发外部中断。在中断函数中设置标志量，然后在主函数中轮询。\n3.检测到标志量被置位后，拉低CS引脚开启SPI通信，自动获取数据，然后处理。\n SPI配置\n在cubeMX中点点就好了，注意几个要点\n1.时钟相位和极性都是1\n2.传输字长是16bit\n\n 软件代码\n/*ad7606.c*///AD7606引脚配置#define AD7606_FRST_Pin GPIO_PIN_9#define AD7606_FRST_GPIO_Port GPIOE#define AD7606_BUSY_Pin GPIO_PIN_10#define AD7606_BUSY_GPIO_Port GPIOE#define AD7606_BUSY_EXTI_IRQn EXTI15_10_IRQn#define AD7606_CSN_Pin GPIO_PIN_11#define AD7606_CSN_GPIO_Port GPIOE#define AD7606_RESET_Pin GPIO_PIN_12#define AD7606_RESET_GPIO_Port GPIOE#define AD7606_CVA_START_Pin GPIO_PIN_13#define AD7606_CVA_START_GPIO_Port GPIOE#define AD7606_STBY_Pin GPIO_PIN_14#define AD7606_STBY_GPIO_Port GPIOE#define AD7606_RANGE_Pin GPIO_PIN_15#define AD7606_RANGE_GPIO_Port GPIOE//AD7606相关参数#define CHANNEL_COUNT 4 //通道数#define DUMMY_CONVERTIONS 4 // 初始冗余转换次数#define AD7606_CH1 0#define AD7606_CH2 1#define AD7606_CH3 2#define AD7606_CH4 3static volatile uint16_t adc_value[CHANNEL_COUNT] = &#123;0&#125;; // 存储AD7606转换后的数据float voltage[CHANNEL_COUNT] = &#123;0.0&#125;; // 存储电压值volatile uint8_t adc_busy_irq_flag = 0;//AD7606 BUSY引脚中断标志位，触发外部中断后被置位/** * @brief AD7606 硬件复位函数 */void AD7606_Reset(void)&#123;    HAL_GPIO_WritePin(AD7606_RESET_GPIO_Port, AD7606_RESET_Pin, GPIO_PIN_RESET);    HAL_Delay(1); // 等待1毫秒    HAL_GPIO_WritePin(AD7606_RESET_GPIO_Port, AD7606_RESET_Pin, GPIO_PIN_SET);    HAL_Delay(1);    HAL_GPIO_WritePin(AD7606_RESET_GPIO_Port, AD7606_RESET_Pin, GPIO_PIN_RESET);    // Usart_Printf(&amp;huart1, &quot;AD7606 Reset\\r\\n&quot;);&#125;/** * @brief AD7606 初始化函数,设置采样范围为±5v，关闭过采样，关闭休眠模式 */void AD7606_Init(void)&#123;    HAL_GPIO_WritePin(AD7606_STBY_GPIO_Port, AD7606_STBY_Pin, GPIO_PIN_SET); // 使能AD7606工作模式    HAL_GPIO_WritePin(AD7606_CSN_GPIO_Port, AD7606_CSN_Pin, GPIO_PIN_SET);//CS引脚拉高    //配置过采样引脚，不开启过采样    HAL_GPIO_WritePin(AD7606_OS0_GPIO_Port, AD7606_OS0_Pin, GPIO_PIN_RESET);    HAL_GPIO_WritePin(AD7606_OS1_GPIO_Port, AD7606_OS1_Pin, GPIO_PIN_RESET);    HAL_GPIO_WritePin(AD7606_OS2_GPIO_Port, AD7606_OS2_Pin, GPIO_PIN_RESET);    // 设置采样范围为±10v：高电平±10V，低电平±5V    HAL_GPIO_WritePin(AD7606_RANGE_GPIO_Port, AD7606_RANGE_Pin, GPIO_PIN_RESET);    // Usart_Printf(&amp;huart1, &quot;AD7606 Range set to ±5V\\r\\n&quot;);    AD7606_Reset();    HAL_Delay(10);&#125;/** * @brief 启动AD7606转换 */void AD7606_StartConvert(void)&#123;    // 拉低convst引脚，产生转换开始信号    HAL_GPIO_WritePin(AD7606_CVA_START_GPIO_Port, AD7606_CVA_START_Pin, GPIO_PIN_RESET);    HAL_GPIO_WritePin(AD7606_CVA_START_GPIO_Port, AD7606_CVA_START_Pin, GPIO_PIN_SET);    //而后会触发AD7606的BUSY引脚中断，读取数据&#125;/** * @brief 处理AD7606的BUSY引脚中断 * @param GPIO_Pin 触发中断的引脚 */void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)&#123;    if (GPIO_Pin == AD7606_BUSY_Pin) // 判断是否是AD7606的BUSY引脚触发的中断    &#123;        adc_busy_irq_flag=1;    &#125;&#125;/** * @brief 获取AD7606转换后的数据 * @return uint16_t* 指向存储ADC数据的数组 */const float* AD7606_GetData(void)&#123;    // TinyCmd_Report(&quot;BUSY中断触发,启动SPI接收\\r\\n&quot;); // 确认调试是否进入中断    // 读取AD7606的数据    HAL_GPIO_WritePin(AD7606_CSN_GPIO_Port, AD7606_CSN_Pin, GPIO_PIN_RESET);                                 // 片选拉低    HAL_StatusTypeDef status = HAL_SPI_Receive(&amp;hspi4, (uint8_t *)adc_value, CHANNEL_COUNT, 1000); // 读取数据    HAL_GPIO_WritePin(AD7606_CSN_GPIO_Port, AD7606_CSN_Pin, GPIO_PIN_SET);                                   // 接收完成后释放片选    if (status != HAL_OK)    &#123;        TinyCmd_Report(&quot;SPI接收启动失败: %d\\r\\n&quot;, status);    &#125;    else    &#123;        // 将接收到的数据转换为电压值        for (uint8_t i = 0; i &lt; CHANNEL_COUNT; i++)        &#123;            int16_t raw_adc_value = (int16_t)adc_value[i]; // 原始ADC值是16位有符号整数            // 转换为电压值，假设参考电压为5V，分辨率为16位            voltage[i] = (float)(raw_adc_value * 5.0f / 32768.0f);        &#125;        return (const float *)voltage;    &#125;    return NULL;&#125;\n/*main.c*/int main(void)&#123;    // 其他必要初始化，如SPI    // 初始化ad7606    AD7606_Init();    /* Infinite loop */    /* USER CODE BEGIN WHILE */    while (1)    &#123;        AD7606_StartConvert();//开启转换        HAL_Delay(100);        const float *ad7606_data = NULL;        ad7606_data = AD7606_GetData();//获取数据        if(NULL!=ad7606_data)        &#123;            //处理数据        &#125;        else        &#123;            //错误处理        &#125;    /* USER CODE END WHILE */  &#125;&#125;\n 问题分析\n最开始的时候我使用的不是这个逻辑，而是用了SPI4的中断。\n1.首先把start_convert函数放在main函数中循环，等待busy引脚触发。\n2.然后在外部中断引脚的回调函数中，直接触发转换，拉低CS，使用HAL_SPI_Receive_IT()函数触发接收。这个函数和HAL_SPI_Receive()的区别是：该函数SPI传输是在后台进行的，传输完成后会触发SPI_Rx中断，通知程序传输完成，没有IT的版本是阻塞式传输的。\n3.在SPI的传输完成中断回调函数中拉高片选，结束传输，并将一个adc_data_ready_flag置位。\n4.main函数中轮询adc_data_ready_flag，被置位时处理数据。\n使用这种思路遇到的问题是adc_data_ready_flag不会被置位，无法取到有用的数据。\n最开始遇到这种问题，我首先考虑到是否是中断优先级的问题。\n在我的项目中涉及中断如下：\n1.USART1空闲中断（cmd，Debug接口）：0，0\n2.SPI4接收中断（AD7606数据接收）：1，0\n3.EXTI15_10外部中断（AD7606 Busy引脚中断）：1，0\n我一直以为是串口和SPI的操作逻辑造成了死锁，最终尝试和很多种优先级都会卡在SPI回调，最终还是没有直接解决这个问题，于是我换了一个思路。\n考虑到项目中另一个HDC1080的温湿度计，连中断都没开，也可以正常读取。于是我就放弃了SPI中断，转而在Busy引脚中置位标志量。剩下的操作放在main中。也就是现在的[[#基本思路]]。\n现在想来，原本的最开始的想法其实很糟糕，有两个大的问题：\n1.将一个器件的完整的通信时序拆分在两个中断（回调）函数中完成。这是很错误的操作，中断回调函数的触发完全不受控，而通信时序又对时机有很高的要求。因此，应该将对同一个器件的一次完整通信过程看作具有一定”原子性“的操作，尽量在同一代码块中完成。\n2.在中断回调中做了太多操作。虽然在我看来这点操作量不会导致问题，但为了解决问题，我还是把所有操作都放在main中，只在回调中做了置位操作。\n最终导致SPI回调卡住的直接原因还是没有找到，但侧面绕过了这个问题，就不必要非要深究那些莫名其妙的bug了。虽然”不要在中断函数中进行复杂操作“这句话都听烂了，但其实没怎么放在心上，果然有些坑只有自己踩过才长记性。\n","categories":["嵌入式","单片机","STM32"],"tags":["stm32","HAL库","SPI","ADC","f429"]},{"title":"STM32F429 HAL库硬件SPI操作AD5676记录","url":"/2025/09/10/STM32F429%20HAL%E5%BA%93%E7%A1%AC%E4%BB%B6SPI%E6%93%8D%E4%BD%9CAD5676%E8%AE%B0%E5%BD%95/","content":" 型号分类\nAD5676是用于输出电压的DAC，8通道，16位输出精度，满量程输出为2.5V或5V。\n还有另一个型号位AD5672，8通道，12位输出精度。\n\n 硬件连线\n\n 引脚介绍\n\n 软件编程\n 配置硬件SPI\n\n 拼接命令字\n设置电压值需要\n1.命令字：采用何种方式设置通道电流，可以控制DAC各种操作。一般选择0011：“写入并更新DAC通道n”\n\n2.地址字：要设置的通道\n\n数据手册中说，可以使用地址位来选择任意组合的DAC通道。感觉这句话有点问题，因为把通道组合起来能表示的信息不唯一。\n例如：传入0011地址，究竟表示单独操作通道3，还是通道1（0001）和通道2（0002）两者一起操作？\n因此编程中还是一次操作一个通道。\n3.数据字：要设置的电压值，需要将浮点数转化为uint16_t\nstatic uint16_t AD5676_Vol2Code(float vol)&#123;    uint16_t code = 0;    code = (uint16_t)(((vol * 65535.0f) / 5.0f));    return code;&#125;\n\n最终要发送的数据刚好24字节，使用3字节大小的数组存储并按顺序发送即可。\n 软件代码\n#define AD_5676_CH1_ADDR 0x0#define AD_5676_CH2_ADDR 0x1#define AD_5676_CH3_ADDR 0x2#define AD_5676_CH4_ADDR 0x3#define AD_5676_CH5_ADDR 0x4#define AD_5676_CH6_ADDR 0x5#define AD_5676_CH7_ADDR 0x6#define AD_5676_CH8_ADDR 0x7// 定义AD5676的命令#define AD_5676_CMD_W_INPUT_REG 0x01 // 写入输入寄存器#define AD_5676_CMD_U_DAC_REG 0x02 // 以输入寄存器n的值更新DACn的输出#define AD_5676_CMD_W_U_SINGLE 0x03 // 写入并直接更新通道输出#define AD_5676_CMD_W_U_ALL_INPUT_REG 0x10 // 用输入数据写入并更新所有通道的输入寄存器#define AD_5676_CMD_W_U_ALL_INPUT_DAC_REG 0x11 // 用输入数据写入并更新所有通道的输入寄存器和DAC寄存器#define AD_5676_SOFT_RESET 0x06 // 软复位// 定义AD5676的SPI数据帧拼接宏#define AD_5676_ADDR(x) ((x) &amp; 0x0F)#define AD_5676_CMD(x) (((x) &lt;&lt; 4) &amp; 0xF0)#define AD_5676_VAL_H(x) (((x) &gt;&gt; 8) &amp; 0xFF)#define AD_5676_VAL_L(x) ((x) &amp; 0xFF)void AD5676_Reset(void)&#123;    // 复位    HAL_GPIO_WritePin(AD5676_RSTN_GPIO_Port, AD5676_RSTN_Pin, GPIO_PIN_RESET);    HAL_Delay(1); // TODO：引入RTOS后delay全部替换    HAL_GPIO_WritePin(AD5676_RSTN_GPIO_Port, AD5676_RSTN_Pin, GPIO_PIN_SET);    HAL_Delay(1);&#125;void AD5676_Init(void)&#123;    // 初始化AD5676的GPIO引脚    HAL_GPIO_WritePin(AD5676_CS_GPIO_Port, AD5676_CS_Pin, GPIO_PIN_SET); // 片选引脚拉高    HAL_GPIO_WritePin(AD5676_SCLK_GPIO_Port, AD5676_SCLK_Pin, GPIO_PIN_RESET); // 时钟引脚拉低    HAL_GPIO_WritePin(AD5676_SDI_GPIO_Port, AD5676_SDI_Pin, GPIO_PIN_RESET); // 数据输入引脚拉低    // 复位AD5676    AD5676_Reset();&#125;static uint16_t AD5676_Vol2Code(float vol)&#123;    uint16_t code = 0;    code = (uint16_t)(((vol * 65535.0f) / 5.0f));    return code;&#125;HAL_StatusTypeDef AD5676_SetOutput(uint8_t channel_addr, float vol)&#123;    HAL_StatusTypeDef result = HAL_ERROR;    uint8_t buf[3];    uint16_t code = AD5676_Vol2Code(vol);    buf[0]=AD_5676_CMD(AD_5676_CMD_W_U_SINGLE) | AD_5676_ADDR(channel_addr);    buf[1]=AD_5676_VAL_H(code);    buf[2]=AD_5676_VAL_L(code);    HAL_GPIO_WritePin(AD5676_CS_GPIO_Port, AD5676_CS_Pin, GPIO_PIN_RESET);//拉低片选    result = HAL_SPI_Transmit(&amp;hspi2, buf, sizeof(buf), 100);    HAL_GPIO_WritePin(AD5676_CS_GPIO_Port, AD5676_CS_Pin, GPIO_PIN_SET);//拉高片选    return result;&#125;\n最终输出的电压精度挺高的，用精度较高的万用表测，误差在0.1mv\n","categories":["嵌入式","单片机","STM32"],"tags":["stm32","HAL库","SPI","DAC"]},{"title":"Ubuntu 无法使用root登录","url":"/2025/09/10/Ubuntu%20%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8root%E7%99%BB%E5%BD%95/","content":" Ubuntu root用户登录\n在 Ubuntu 系统中，默认情况下 root 用户是无法直接通过密码登录的。Ubuntu 的设计理念是不建议直接使用 root 用户登录系统（包括本地和远程登录），而是使用普通用户并通过 sudo 提升权限。\n 原因\nUbuntu 默认禁用 root 用户的密码，因此 root 用户在本地控制台尝试登录时，也会因为没有设置密码而失败。即使为 root 用户设置了密码，许多 Ubuntu 版本仍然通过 PAM（可插入认证模块）配置禁止 root 用户登录到 GUI。\n Ubuntu 系统默认的 root 用户登录策略\n\n\n默认禁用 root 用户密码：\n\n在 Ubuntu 中，root 用户的密码是禁用的，因此即使尝试登录 root，系统也不会允许。\n默认情况下，Ubuntu 创建的第一个用户是管理员，拥有 sudo 权限，可以通过 sudo 提升权限来完成管理任务。\n\n\n\n推荐使用 sudo：\n\nUbuntu 通过 sudo 提供了一个更安全的权限提升方式，避免直接使用 root 用户。\n使用 sudo 的好处是，管理员任务可以由普通用户临时获得权限，并且所有使用 sudo 的操作都会被记录下来，便于审计。\n\n\n\n 允许 root 通过密码本地登录\n如果确有需要启用 root 用户的本地登录，可以执行以下步骤：\n\n\n为 root 用户设置密码（如果还没有设置）：\nsudo passwd root\n设置密码后，root 用户的密码认证将被启用。\n\n\n检查并修改 PAM 配置：\n\n\n确保 /etc/pam.d/gdm-password（适用于 GNOME 桌面环境）或 /etc/pam.d/login 文件中没有阻止 root 登录的配置。\n\n\n检查是否有类似 auth required pam_succeed_if.so user != root quiet_success 的行。这一行会阻止 root 用户通过 GUI 登录。\n如需允许 root 用户登录，可以将这一行注释掉：\n\n\n\n\n# auth required pam_succeed_if.so user != root quiet_success\n\n重新启动登录管理器（例如 gdm、lightdm）以使更改生效：sudo systemctl restart gdm\n\n\n 允许 root 通过密码ssh登录\n如果确实需要允许 root 用户直接登录，可以按照以下步骤进行配置：\n\n\n为 root 用户设置密码：\n\n你需要先为 root 用户设置一个密码：sudo passwd root\n\n系统会提示输入并确认 root 用户的新密码。\n\n\n\n允许 root 用户通过 SSH 登录：\n\n打开 SSH 配置文件 /etc/ssh/sshd_config：sudo nano /etc/ssh/sshd_config\n\n找到 PermitRootLogin 配置，将其修改为 yes（去掉注释符号 #）：PermitRootLogin yes\n\n保存并退出文件，然后重启 SSH 服务：sudo systemctl restart sshd\n\n\n\n\n 安全性提示\n\n[!error] 警告\n\n启用 root 用户的本地登录存在安全风险，因为它会绕过 sudo 的审计和日志记录功能。一般建议使用普通用户并通过 sudo 提升权限来执行管理任务，而不是直接使用 root 用户。\n\n启用 root ssh登录后，也存在较高的安全风险，容易受到暴力破解攻击。因此，强烈建议仅在必要时临时启用 root 用户登录，并尽可能使用 SSH 公钥认证方式。通过上述配置，root 用户将能够直接登录到系统。但启用后，请确保使用强密码或通过防火墙限制 root 登录的 IP 地址，以提高安全性。\n 如何更新普通用户的密码\nsudo su rootpasswd user #更改user用户密码passwd root #更改root用户密码","categories":["操作系统","linux","ubuntu"],"tags":["OS","Linux","Ubuntu"]},{"title":"c语言专题讲解","url":"/2025/08/31/c%E8%AF%AD%E8%A8%80%E4%B8%93%E9%A2%98%E8%AE%B2%E8%A7%A3/","content":" 1. 指针的基础知识\n 1.1 指针的基本语法\n与指针操作相关的运算符: 解引用运算符*, 取地址运算符&amp;\n指针最基础的语法如下:\n//操作1int contianer = 0;int content = 1;contianer = content;//操作2int * contianer = 0;int content = 1;contianer = &amp;content;printf(&quot;contianer:%d&quot;,*contianer);printf(&quot;contianer:%d&quot;,contianer);printf(&quot;contianer:%x&quot;,contianer);\n对比以上两种操作\n指针用于存储地址, 通过地址可以找寻到该地址处的数据, 或者以该地址为起始地址的数据.\n 1.2 指针的简单应用\n如何实现交换两个数的内容:\ninclude &lt;stdio.h&gt;int main(void)&#123;    char a=&#x27;B&#x27;;//一个盒子里放着篮球    char b=&#x27;A&#x27;;//另一个盒子里放着足球    char temp=&#x27;0&#x27;;//有一个空盒子    //使用一下三步完成交换    temp = a;//篮球放在空盒子里, 原本放篮球的盒子现在为空    a = b;//足球放在空盒子里, 此时原本放足球的盒子是空 注意不是b = a;    b = temp; //空盒子中放入篮球, 完成物体的交换    return 0;&#125;\n以上是基本的交换两个数的实现, 这样写完全没问题. 如果我有10000个这样的数需要交换, 不可能写一万遍代码吧? 很自然的想到, 使用函数, 把重复使用的代码提取成一个函数.\n那么如何写呢?\nvoid swap(char a, char b)&#123;    char temp=&#x27;0&#x27;;    //使用一下三步完成交换    temp = a;//篮球放在空盒子里, 原本放篮球的盒子现在为空    a = b;//足球放在空盒子里, 此时原本放足球的盒子是空 注意不是b = a;    b = temp; //空盒子中放入篮球, 完成物体的交换&#125;\n好了这个函数实现了\n接下来在主函数调用一下:\ninclude &lt;stdio.h&gt;void swap(char a, char b)&#123;    char temp=&#x27;0&#x27;;    //使用一下三步完成交换    temp = a;//篮球放在空盒子里, 原本放篮球的盒子现在为空    a = b;//足球放在空盒子里, 此时原本放足球的盒子是空 注意不是b = a;    b = temp; //空盒子中放入篮球, 完成物体的交换&#125;int main(void)&#123;    char a=&#x27;B&#x27;;//一个盒子里放着篮球    char b=&#x27;A&#x27;;//另一个盒子里放着足球    char temp=&#x27;0&#x27;;//有一个空盒子    //使用一下三步完成交换    swap(a,b);    //把盒子里的球倒出来看看    printf(&quot;box a:%c box b:%c\\n&quot;);    return 0;&#125;\n在这里给出输出\n可以看出输出不对, 盒子里的球并没有被交换\n为什么会这样?\n原因在与swap函数\n函数的形式参数和实际参数\n\n对于函数的参数：\n在声明和定义时写在函数参数列表中的参数是形式上的参数, 起到占位置的作用, 所以叫形式参数, 简称形参.\n形参在你调用函数时告诉你这里应当填什么样的数据.\n在调用函数时, 写入到参数列表的参数才是实际用到的参数, 称为实际参数, 简称实参.\n\n在这里, 我们把两个参数传入其中, 只是在形参之间换来换去, 没有影响到实参.\n试想一下, swap这个机器, 伸出两只机械臂, 要求你把篮球和足球放上去, 于是你另外拿了两个球给它, 它把球左手倒右手一换, 对你手上两个的盒子和其中的内容却没有任何影响.\n请注意, 我们的要实现交换两个球的目的, 不只要关心这两个球之间的关系, 还要关心球与盒子之间的关系, 一共是四个元素而不是两个元素.\n那么有没有一种东西, 既可以操作盒子, 又可以操作盒子中的内容呢?\n你好, 有的, 兄弟, 有的! 看一下指针吧, 兄弟!\n指针本体可以操作盒子, 通过解引用操作可以操作盒子内的物品, 两个要求, 一次满足, 简直太完美了.\n于是就可以实现一个新的swap函数:\nvoid new_swap(char * a, char * b)&#123;    char temp = &#x27;0&#x27;;    temp = *a;    *a = *b;    *b = temp;&#125;//由于参数是两个指针, 因此调用函数传入参数时要注意使用取地址运算符传入地址int main(void)&#123;    char a=&#x27;B&#x27;;//一个盒子里放着篮球    char b=&#x27;A&#x27;;//另一个盒子里放着足球    char temp=&#x27;0&#x27;;//有一个空盒子    //使用一下三步完成交换    swap(&amp;a,&amp;b);    //把盒子里的球倒出来看看    printf(&quot;box a:%c box b:%c\\n&quot;);    return 0;&#125;\n 2. 指针和内存空间\n 2.1 不同类型数据占据的存储空间\n为了合理的存储不同大小的数据, 既不浪费, 也不溢出, 有不同数据类型.\n为了应对不同的数据类型, 指针也有了不同的类型. 但是指针的类型和数据类型有一些区别.\n我们知道, 不同数据类型的本质区别就是占据的空间大小不同.\n\n(此处给出数据类型大小表格)\n我们使用sizeof()运算符可以计算数据的大小, sizeof的用法类似函数(但它实际上不是参数而是运算符), 括号中传入参数, 返回一个数字(该返回值的类型为size_t) 表示传入的参数的占据空间大小, 以字节为单位.\nprintf(&quot;size of char:%d&quot;,sizeof(char));printf(&quot;size of short:%d&quot;,sizeof(short));printf(&quot;size of int:%d&quot;,sizeof(int));\n照这样来看数组应该根据存储数据类型的不同, 拥有不同的大小, 然而事实却不是这样. 一般来说, 指针拥有固定的大小.\n原因也很简单, 指针存储的是地址, 所有的地址都是同一类型的数据, 不论是char还是int, 都是地址. 所以占据的大小都是相同的.\n那么可以说所有的指针都是同一类型的数据吗?\n当然不能.\n虽然指针本身所占的空间大小相同, 但其中包含的地址所指向的数据本身却是不同的.\nchar * char_ptr;short * short_ptr;int * int_ptr;\n以上的数据声明中, 有char *, short *, int * 三种不同类型的数据, 可以这样理解, 其中的*(解引用运算符)表示这三者都是指针, 而char, short, int表示其中存储的数据的不同类型. 这两个方面的信息共同构成了指针的类型.\n当计算机根据指针中存储的地址找到所在位置之后, 通过声明指针变量是给出char, int或其他数据类型的信息决定取一个字节或四个字节的数据.\nvoid 类型 和void* 类型\n\nvoid 表示无类型，不能直接用来定义变量，如void x=0;这条语句是不合法的。用在函数头的返回值或参数列表中，表示函数无参或无返回值。如void func(void)，表示一个既无参数有无返回值的函数。\nvoid*表示无类型指针，可以用来定义变量，void* ptr=&amp;x;该语句是合法的。void*是为了满足一些函数的适配性而设计的（即泛型编程），例如，设计一个函数long sumof(int a,int b)用于计算两个数之和，因为不能确定要计算的两个数的大小，如果给出的参数超出了int类型的限制就会产生意想不到的结果。将其修改为void* sumof(void* a,void* b,DATA_TYPE type)，不论数据有多大，先接受了再说，同时传入数据类型，根据数据类型，在函数中采用不同的处理方式即可。\n为何void不可以直接用于定义变量而void*可以？\nvoid*归根到底是一个指针，用该类型定义变量编译器知道用多少内存来存储该变量，因为一台机器上的指针类型大小是固定的。而对于void类型的变量，编译器不知道该使用多大的内存来存储，因此无法直接定义变量。相应的，由于void*类型没有数据类型，因此不能直接对void*指针直接解引用，也不能直接使用++运算符。例如，语句int a=0; void* ptr = &amp;a; b=*ptr和void* ptr=&amp;a; ptr++;都是不合法的。\n\n 2.2 寻址空间和指针大小\n我们知道指针的大小一般都是相同的，那么会是多大呢？可以使用sizeof()运算符测算\nint a=10;char b=&#x27;a&#x27;;float c=1.1;int *ptr1=&amp;a;char *ptr2=&amp;b;float *ptr3=&amp;c;printf(&quot;size of ptr1 = %d\\n&quot;,sizeof(ptr1));printf(&quot;size of ptr2 = %d\\n&quot;,sizeof(ptr2));printf(&quot;size of ptr3 = %d\\n&quot;, sizeof(ptr3));//输出size of ptr1 = 8size of ptr2 = 8size of ptr3 = 8\n大部分情况下, 结果都会是8. 这表示指针类型占据8字节空间大小.\n指针占据的空间是由CPU的寻址位数所决定的,  CPU的寻址位数决定了其能够访问的内存地址的范围，也决定了指针变量能够存储的地址值的位数。例如，在32位机器上，地址是由32个0或1的二进制序列组成，因此指针大小通常是4个字节（因为1个字节=8比特位，32比特位=4个字节）。而在64位机器上，地址需要64个0或1的二进制序列组成，因此指针大小通常是8个字节。\n当然cpu寻址位数并不是唯一的决定因素, 编译器的编译方式, 虚拟化技术的使用等其他原因可能导致指针大小与实际的CPU不匹配.\ncpu的寻址位数, 另一种说法, 也就是cpu的地址总线宽度, 决定了系统的地址空间的大小.\n我们在一些软件的release版本中经常能看见x86和x64后缀.\nx86是一种32位处理器架构，它广泛被应用于早期的计算机系统中。由于历史原因和广泛的兼容性，许多旧的软件和操作系统仍然基于x86架构。x86架构的处理器能够支持的内存寻址范围为2^32（约4GB），这在一定程度上限制了其在处理大数据和复杂计算任务时的能力。然而，对于许多日常应用和旧版软件来说，x86架构仍然足够满足需求。\n相比之下，x64（也称为x86-64或AMD64）是一种64位处理器架构，它提供了更大的内存寻址范围和更高的计算能力。x64架构的处理器能够支持的内存寻址范围为2^64（实际限制通常为16EB，即160亿GB），这使得它能够轻松应对大数据处理和复杂计算任务。此外，x64架构还向下兼容32位应用程序，这意味着用户可以在64位操作系统上运行旧的32位软件。\n因此，当软件的release版本后缀带有x86或x64时，这表示该软件分别针对32位或64位的处理器架构进行了优化。用户应该根据自己的操作系统和硬件平台选择合适的版本进行安装。如果你的操作系统是64位的，并且你的计算机硬件支持x64架构，那么建议选择x64版本的软件以获得更好的性能和兼容性。如果你的操作系统或硬件平台是32位的，或者你需要运行一些只能在32位环境下运行的旧版软件，那么你可能需要选择x86版本的软件。\n(推书) 汇编语言–王爽\n 2.3 数据的存储方式\n 2.3.1 问题的引入\nint int_data=0x12345678;char * char_ptr=NULL;char_ptr = (char *)(&amp;int_data);printf(&quot;0x%x&quot;,*char_ptr);\n以上示例输出内容是什么?\n在不同的平台上,  输出内容会有差别, 大部分人在PC上应该输出的是0x78, 而在一些特定平台, 则会输出0x12.\n原因是什么?\n先看看以上操作在干嘛,  定义一个int类型的变量, 取这个变量的地址, 强制类型转换成char*类型的指针, 并通过指针来访问该地址的内容.\n还记得我说的指针的类型的含义吗, char * 表示在数组存储的地址上访问sizeof(char) 大小的字节数目(1个字节), int *表示在数组存储的地址上访问sizeof(int) 大小的字节数目(一般为4个字节).\n也就是说, 原本的四字节大小的int_data通过这种访问方式被截断为一个字节\n在定义时, int_data被赋值为0x12345678, 其中0x表示其后的数据是16进制格式, 也就是说, 刚巧12,34,56,78分别各是一个字节\n0x12=0b 0001 0010 , 其他字节内容类似.\n接下来就是最关键的问题: 在四个字节的内容被裁剪为一个字节的情况下, 哪个字节会被返回?\n 2.3.2 字节序和存储模式\n从直觉来看, 最开始的12和最末尾的78应该是最有可能的, 结果也是符合直觉的.\n再来看一看这个数: 12 34 56 78.\n我们读这个数是从12开始, 而这个数的最低位是78, 如果把这个数看成10进制,则 8是个位, 7是十位, 虽然16进制没有个位十位的说法, 但是原理是类似的, 8是最低位, 7是次低位.\n78是最低字节(LSB, least significant byte), 相应的, 12是最高字节(MSB, most significant byte). 字节的高低称作字节序\n不论一个数是按照十进制还是十六进制, 或是二进制, 八进制等等, 数字总有其排列顺序.\n数中的字节讲顺序, 计算机里的存储也讲顺序, 计算机内存按照地址进行编号, 从0开始到虚拟地址空间的最大值, 依次增加, 数据依次存储在其中. 0x1000是低地址, 0x1003是高地址\n根据字节序的存储地址不同, 可以分为两种存储模式\n\n大端存储：在大端存储模式下，数据的高字节（或称作高位、最重要字节）被存储在内存的低地址处，而数据的低字节（或称作低位、最不重要字节）存储在高地址处。这意味着当你从低地址向高地址读取内存时，数据会按照从高到低的顺序出现。例如，对于十六进制数0x1234，在大端模式下，内存中的布局就是0x12在前（低地址），0x34在后（高地址）。\n小端存储：在小端存储模式下，数据的低字节存储在内存的低地址处，而高字节存储在高地址处。也就是说，当你从低地址开始读取时，最先读到的是数据的低字节，然后才是高字节。对于相同的十六进制数0x1234，在小端模式下，内存布局会是0x34在前（低地址），0x12在后（高地址）。\n\n于是, 对于0x12345678\n\n在大端存储模式下：\n\nint_data的内存布局（从低地址到高地址）将是：0x12, 0x34, 0x56, 0x78。\nchar_ptr指向int_data的第一个字节，即0x12。\n因此，printf(&quot;%x&quot;, *char_ptr);将输出12。\n\n\n在小端存储模式下：\n\nint_data的内存布局（从低地址到高地址）将是：0x78, 0x56, 0x34, 0x12。\nchar_ptr指向int_data的第一个字节，即0x78。\n因此，printf(&quot;%x&quot;, *char_ptr);将输出78。\n\n\n\n因此，该代码在大端存储模式下输出12，在小端存储模式下输出78。\n[[C语言指针系列图解.excalidraw]]\n使用以下方式可以判断机器是那种存储方式?\n#include &lt;stdio.h&gt;int main() &#123;    int num = 1;    if (*(char *)&amp;num == 1) &#123;        printf(&quot;Little-endian\\n&quot;);    &#125; else &#123;        printf(&quot;Big-endian\\n&quot;);    &#125;    return 0;&#125;\n注意\n\n你应当注意到了, 不论指针所指向的数据占据的内存空间有多大, 它总是指向数据占据的最低地址, 这一点在数组中也是适用的, 具体会在接下来的3.指针与数组部分详解.\n\n 3. 指针和数组\n 3.1 使用指针操作数组\n数组被用来存储一系列相同类型的数据\nint a[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125;;\n对于数组的基本用法这里不多赘述, 如果不了解建议补充一下基础知识.\n我们知道, 数组通过数组下标取数\nint x=a[0];\n取数组的第一个元素赋值给变量x.\n然而还有另一种用法, 数组名是一个相应类型的指针.\n以上例子中, a可以直接赋值给int *类型的指针使用，且是一个合法地址。该地址是数组第一个元素的地址。\nint * int_ptr=a;\n以上写法, 编译既不会报错, 也不会警告. 是合法合规而且经常使用的写法.\n于是, 对于数组的元素的访问, 可以有两种不同的方式完成.\nint a[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125;;int data1=a[0];//访问第一个数组元素int data2=*(a+1);//访问第一个数组元素之后的一个元素printf(&quot;data1:%d&quot;,data1);printf(&quot;data2:%d&quot;,data2);//输出:data1:1data2:2\n 指针运算\n以上代码涉及到一个新的操作：指针运算\n仔细观察其中的写法,：*(a+1), 表示a增加“1”, 然后解引用。\n一般来说, “加1”操作是直接作用在数值上的，加上1就是数值变大1，但是对于指针来说, 这个1不是大小上的1, 而是单位1.\n这里的单位1为指针存储的类型所占的字节数。\n之前讲解过, 对于char *,int*等不同类型的指针的含义:\n“char * 表示在数组存储的地址上访问sizeof(char) 大小的字节数目(1个字节), int *表示在数组存储的地址上访问sizeof(int) 大小的字节数目(一般为4个字节)”\n对于char *类型的数据, 自增以char类型的大小为单位1, 其值就是1个字节.\n假设char * char_ptr=0x1000 那么char_ptr+1后, 其值为0x1001. 而如果是int_ptr+1, 其值为0x1004. 其他类型与此相似.\n(在这里给出数组数据在内存中的排列)\n[[C语言指针系列图解.excalidraw]]\n指针运算的这种设计极好的契合了数组操作, 数组各个元素可以直接依照自增取数.\nint a[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125;;    for(int i=0;i&lt;10;i++)    &#123;        printf(&quot;%d\\n&quot;,*(a+i));        printf(&quot;%d\\n&quot;,a[i]);    &#125;\n以上两种写法都能遍历数组\n数组名和指针的区别\n\n看了以上的内容，你可能会认为数组名就是一个指向数组首元素地址的指针，并完全把它当作指针来使用。但数组名不是一个指针，和不能混为一谈。请看如下示例：\n&gt;int arr[5]=&#123;1,2,3,4,5&#125;;&gt;int a=*(arr++);&gt;//报错：error: lvalue required as increment operand\n以上代码中arr++操作是不合法的，编译报错的意思是说++运算符需要一个左值作为其操作数，虽然数组名是一个左值，但不是一个可以修改的左值。这样是有原因的，数组名作为一个数组的标识（symbol）应该永远指向数组的首地址，不应被任何操作更改，这样才能保证对数组任意元素的正常访问。\n那么为什么arr+1这样的操作是合法的？\n原因是”+1“操作不会改变arr本身的值，arr+1这样的表达式最终的结果是一个右值，终究是要赋值给某个变量或作为其他运算符的操作数使用。无论是哪种情况，都不会影响arr中存储的值。\n\n 3.2 数组到指针的退化\n在 C/C++ 中，​数组到指针的退化（array-to-pointer decay）​​ 是一个重要的隐式转换机制，它决定了数组名在大多数情况下如何被自动转换为指针。理解这个概念对掌握 C/C++ 的指针和数组操作至关重要。\n\n ​1. 什么是数组到指针的退化？​​\n\n​数组名 arr 在大多数表达式中会自动转换为指向其首元素的指针。\n这种转换是隐式的（编译器自动完成），称为 ​​&quot;退化（decay）&quot;​。\n退化后，数组名 arr 不再代表整个数组，而是变成一个指向 arr[0] 的指针（类型 T*，其中 T 是数组元素的类型）。\n\n​示例​\nint arr[5] = &#123;1, 2, 3, 4, 5&#125;;int *p = arr;  // 数组名 arr 退化为 int* 指针\n\narr 原本是一个 int[5] 类型的数组，但在赋值给 p 时，它退化为 int* 类型（指向 arr[0]）。\n\n\n ​2. 何时发生数组到指针的退化？​​\n数组名在以下情况下会退化为指针：\n\n​作为函数参数传递时​：\n\nvoid func(int *p);  // 函数接受指针int arr[5] = &#123;1, 2, 3, 4, 5&#125;;func(arr);  // arr 退化为 int* 指针\n\n即使函数声明为 void func(int p[5])，p 仍然会被当作 int* 处理（数组语法只是语法糖）。\n\n\n​在算术运算（+, -, ++, --）中​：\n\nint *p = arr + 1;  // arr 退化为指针，然后 +1 运算\n\n​在 [] 运算符中​：\n\nint val = arr[2];  // 等价于 *(arr + 2)\n\n​在比较运算 （ !=, &lt;, &gt; 等）中​：\n\nif (arr == NULL) &#123; ... &#125;  // arr 退化为指针\n\n​在初始化指针时​：\n\nint *p = arr;  // arr 退化为指针\n \n ​3. 何时不会发生退化？​​\n数组名在以下情况下不会退化为指针，仍然保持数组类型：\n\n\n​**sizeof(arr)**​：\n size_t size = sizeof(arr);  // 返回整个数组的大小（5 * sizeof(int)）\n\n如果 arr 退化为指针，sizeof(arr) 会返回指针的大小（如 4 或 8 字节），而不是数组大小。\n\n\n\n​**&amp;arr（取数组地址）​**​：\n int (*ptr_to_array)[5] = &amp;arr;  // 返回 int(*)[5] 类型（数组指针）\n\n&amp;arr 返回的是指向整个数组的指针​（int(*)[5]），而不是指向首元素的指针（int*）。\n\n\n\n​字符串字面量初始化字符数组时​：\n char str[] = &quot;hello&quot;;  // str 是数组，不会退化为指针\n\n\n\n ​4. 退化后的指针类型​\n\n\n如果 arr 是 T[N] 类型（T 是元素类型，N 是数组大小），则退化后的指针类型是 T*。\n\n\n​示例​：\n  int arr[5];     // 类型是 int[5]int *p = arr;   // 退化后 p 的类型是 int*\n\n\n\n ​5. 退化与指针算术​\n由于退化后的 arr 变成 T*，我们可以对它进行指针算术运算：\nint arr[5] = &#123;1, 2, 3, 4, 5&#125;;int *p = arr;     // p 指向 arr[0]int *q = p + 3;   // q 指向 arr[3]（即 4）\n\narr + i 等价于 &amp;arr[0] + i，计算的是第 i 个元素的地址。\n\n\n ​6. 退化与多维数组​\n对于多维数组，退化规则仍然适用，但会逐层退化：\nint matrix[3][4];  // int[3][4] 类型\n\n​**matrix 退化为 int(*)[4]**​（指向 int[4] 的指针）。\n​**matrix[0] 退化为 int***​（指向 int 的指针）。\n\n​示例​\nint (*p)[4] = matrix;  // p 指向 matrix[0]（int[4] 类型）int *q = matrix[0];    // q 指向 matrix[0][0]（int 类型）\n\n ​7. 退化带来的问题​\n由于退化是隐式的，可能会导致一些意外的行为：\n​​(1) 数组大小信息丢失​\nvoid func(int *p) &#123;    // 无法知道 p 指向的数组有多大！&#125;int arr[5] = &#123;1, 2, 3, 4, 5&#125;;func(arr);  // 退化后，func 不知道 arr 的大小\n\n\n​解决方案​：显式传递数组大小：\n  void func(int *p, size_t size);func(arr, sizeof(arr)/sizeof(int));\n\n\n​**​(2) 不能对退化后的指针使用 sizeof**​\nint arr[5];int *p = arr;size_t s1 = sizeof(arr);  // 20（假设 int 是 4 字节）size_t s2 = sizeof(p);    // 4 或 8（指针的大小）\n\nsizeof(arr) 返回整个数组的大小，但 sizeof(p) 返回指针的大小。\n\n\n ​8. 如何避免退化？​​\n如果希望保留数组类型（防止退化），可以使用：\n\n\n​引用传递（C++）​​：\n void func(int (&amp;arr)[5]);  // 接受 int[5] 类型的引用int arr[5] = &#123;1, 2, 3, 4, 5&#125;;func(arr);  // 不会退化\n\n这样 sizeof(arr) 在函数内部仍然有效。\n\n\n\n​使用 std::array（C++）​​：\n #include &lt;array&gt;std::array&lt;int, 5&gt; arr = &#123;1, 2, 3, 4, 5&#125;;\n\nstd::array 是 C++ 的容器，不会退化。\n\n\n\n\n ​9. 总结​\n\n\n\n​关键点​\n​说明​\n\n\n\n\n​什么是退化？​​\n数组名 arr 在大多数情况下隐式转换为 &amp;arr[0]（指针）。\n\n\n​何时发生？​​\n函数传参、指针运算、[] 操作、比较运算等。\n\n\n​何时不发生？​​\nsizeof(arr), &amp;arr, 初始化字符数组时。\n\n\n​退化后的类型​\nT[N] → T*（指向首元素的指针）。\n\n\n​多维数组退化​\nint[3][4] → int(*)[4]（指向行的指针）。\n\n\n​退化的问题​\n丢失数组大小信息，sizeof 行为不同。\n\n\n​如何避免？​​\n使用引用（C++）或 std::array（C++）。\n\n\n\n理解 ​array-to-pointer decay​ 能帮助你更好地掌握 C/C++ 的数组和指针操作，避免常见的陷阱！ 🚀\n 3.3 在数组中使用sizeof()\n有如下代码示例，尝试运行，看看结果和你想的是否相同:\nint arr[5] = &#123;1, 2, 3, 4, 5&#125;;int *ptr=arr;printf(&quot;size of arr:%d&quot;,sizeof(arr));printf(&quot;size of ptr:%d&quot;,sizeof(ptr));\n继续来看遍历数组的例子\nint a[]=&#123;2,3,4,2,35,624,546,31,0,46&#125;;int arr_size=10;    for(int i=0;i&lt;arr_size;i++)    &#123;        printf(&quot;%d\\n&quot;,*(a+i));        printf(&quot;%d\\n&quot;,a[i]);    &#125;\n遍历数组是, for循环的终止条件是数组的长度.\n直接在循环中写出数组长度的数字是一种不推荐的写法, 有几个缺点:\n\n对于明确给出长度的数组, 我们可以直接知道它的长度, 但对于没有给出长度的数组, 不能一眼看出它的长度.\n直接在for循环中使用数组长度的数字,  是一种硬编码方式, 如果要改动数组大小, 那么每一个在程序中用到的数组遍历操作都要更改代码, 非常麻烦.\n\n更推荐使用的方法是使用sizeof()运算符:\n具体操作如下:\narr_size = sizeof(arr_name)/sizeof(data_type)\nsizeof(arr_name)计算数组的所有元素占据的字节数, sizeof(data_type)计算数组每个元素占据的字节数. 两个数一除, 就能算出数组大小.\n//使用以上方法遍历数组    int a[]=&#123;2,3,4,2,35,624,546,31,0,46&#125;;    for(int i=0;i&lt;sizeof(a)/sizeof(int);i++)    &#123;        printf(&quot;%d\\n&quot;,*(a+i));        printf(&quot;%d\\n&quot;,a[i]);    &#125;\n\n sizeof和strlen的区别\n在以上示例中提到了数组的一个用法: 即使用字符数组存储字符串. 对于这样的字符串既可以使用sizeof()获取其长度, 也可以使用strlen()\n来看一下sizeof和strlen的区别:\n 1. 定义与性质\n\n\nsizeof\n\n性质：是C/C++中的一个运算符，用于计算变量或数据类型所占的内存大小。\n返回值：其返回值是size_t类型，表示某种类型或对象的字节数。\n计算时机：sizeof是在编译时计算的，而不是运行时，这使得它非常高效。\n\n\n\nstrlen\n\n性质：是C语言标准库中的一个函数，用于计算字符串的长度。\n语法：size_t strlen(const char *str);\n参数：str表示要计算长度的字符串，以’\\0’结尾的字符指针。\n返回值：返回字符串str的字符数量，不包含’\\0’结尾字符。\n计算时机：strlen的结果是在运行时计算出来的。\n\n\n\n 2. 使用场景与限制\n\n\nsizeof\n\n可以用于数据类型、变量、数组、结构体等，返回它们在内存中的大小，单位是字节。\n对于数组，sizeof可以直接给出数组所占用的内存大小。但需要注意，当数组作为函数参数传递时，它会被退化为指针，此时使用sizeof来计算数组的大小将返回指针的大小，而不是数组的实际大小。\n对于指针，sizeof返回的是指针本身的大小，而不是它所指向的内容的大小。\n\n\n\nstrlen\n\n只能用于计算以’\\0’结尾的字符串的长度。\n如果字符串没有以’\\0’结尾，strlen的行为是未定义的，可能会继续计算直到遇到内存中的某个’\\0’字符为止。\nstrlen的参数必须是char*类型的指针，不能用于其他数据类型。\n\n\n\n 3. 示例对比\n以下是一个简单的示例，用于说明sizeof和strlen在实际编程中的使用：\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123;    char str[] = &quot;Hello, World!&quot;;    char *ptr = str;    printf(&quot;Sizeof str: %zu bytes\\n&quot;, sizeof(str));  // 输出数组的大小，包括结尾的&#x27;\\0&#x27;    printf(&quot;Sizeof ptr: %zu bytes\\n&quot;, sizeof(ptr));  // 输出指针的大小    printf(&quot;Strlen of str: %zu\\n&quot;, strlen(str));     // 输出字符串的长度，不包括结尾的&#x27;\\0&#x27;    return 0;&#125;\n在这个示例中，sizeof(str)返回的是数组str所占用的内存大小，包括结尾的’\\0’字符；而sizeof(ptr)返回的是指针ptr本身所占用的内存大小，与它所指向的字符串的长度无关。strlen(str)则返回的是字符串str的长度，不包括结尾的’\\0’字符。\n\n 4. 指针和结构体\n 4.1 基本用法\n使用结构体可以把相关的数据有逻辑的组合在一起, 并通过结构体名称+ .来引用结构体中的变量\n#include &lt;stdio.h&gt;#include &lt;string.h&gt; // 包含strcpy函数的头文件struct Student &#123;    int id;         // 学生学号    char name[50];  // 学生姓名    float score;    // 学生成绩&#125;;int main()&#123;    struct Student stu;//创建一个Student类型的数据stu    stu.id=1;    strcpy(stu.name, &quot;zhangsan&quot;); // 使用strcpy函数复制字符串    stu.score=85.0;&#125;\n可以看出结构体和数组是很像的, 都是用来存储一系列数据的. 二者的区别在于同一结构体中可以包含不同数据类型的数据, 而一个数组中所有数据的数据类型都相同\n结构体中也可以包含数组作为其元素, 如上所示, char name[50]是用于存储学生姓名的数组.\n通过typedef为结构体起一个别名\n//使用typedef定义一个结构体,为其起一个别名//写法1:typedef struct Student&#123;    int id;        // 学生学号    char name[50]; // 学生姓名    float score;   // 学生成绩&#125; Stu;/*起别名后可以一直使用别名,于是结构体原本的名字可以省略掉写法2:typedef struct&#123;    int id;        // 学生学号    char name[50]; // 学生姓名    float score;   // 学生成绩&#125; Stu;*///以上两种写法是一样的int main()&#123;    Stu stu; // 创建一个Stu类型的数据stu.因为起了别名,此处可以直接使用别名    stu.id = 1;    strcpy(stu.name, &quot;zhangsan&quot;); // 使用strcpy函数复制字符串    stu.score = 85.0;&#125;\n 4.2 使用指针操作结构体\n结构体同样可以通过指针来操作\n//使用typedef定义一个结构体,为其起一个别名typedef struct Student&#123;    int id;        // 学生学号    char name[50]; // 学生姓名    float score;   // 学生成绩&#125; Stu;int main()&#123;    Stu stu; // 创建一个Stu类型的数据stu.因为起了别名,此处可以直接使用别名    stu.id = 1;    strcpy(stu.name, &quot;zhangsan&quot;); // 使用strcpy函数复制字符串    stu.score = 85.0;    Stu* ptr_stu;// 创建一个指向Stu类型的指针ptr_stu    ptr_stu-&gt;id = 1;    strcpy(ptr_stu-&gt;name, &quot;zhangsan&quot;); // 使用strcpy函数复制字符串    ptr_stu-&gt;score = 85.0;&#125;\n使用指针同样可以操作结构体成员, 使用指针名+ -&gt;运算符即可.\n既然涉及到了指针操作, 那么来看一看结构体在内存中的存储方式吧\n\n 1. 结构体的存储方式\n结构体在内存中的存储方式是按照其成员变量的声明顺序依次存储的。每个成员变量占用的内存空间取决于其数据类型。例如：\nstruct Example &#123;    char a;    // 1字节    int b;     // 4字节    short c;   // 2字节&#125;;\n在没有考虑对齐的情况下，结构体的内存布局大致如下：\n\n\nchar a 占用1字节。\n\n\nint b 占用4字节。\n\n\nshort c 占用2字节。\n\n\n因此，结构体的总大小应该是 1 + 4 + 2 = 7 字节。然而，实际的存储方式会受到对齐规则的影响。\n\n 2. 结构体的对齐方式\n为了提高内存访问效率，编译器通常会对结构体的成员变量进行对齐（alignment）。对齐规则确保每个成员变量的地址是其大小的整数倍。例如，一个4字节的int变量，其地址必须是4的倍数。\n 2.1 对齐规则\n\n\n成员变量对齐：\n\n\n每个成员变量的起始地址必须是其自身大小的整数倍。例如：\n\n\nchar 类型的变量对齐要求是1字节对齐。\n\n\nshort 类型的变量对齐要求是2字节对齐。\n\n\nint 类型的变量对齐要求是4字节对齐。\n\n\nlong long 类型的变量对齐要求是8字节对齐。\n\n\n\n\n如果成员变量的起始地址不符合对齐要求，编译器会在前面插入填充字节（padding）。\n\n\n\n\n结构体整体对齐：\n\n\n结构体的总大小必须是其最大成员变量对齐要求的整数倍。例如，如果结构体中最大的成员变量是4字节对齐的，那么整个结构体的大小必须是4的倍数。\n\n\n如果结构体的总大小不符合对齐要求，编译器会在结构体的末尾插入填充字节。\n\n\n\n\n\n 3. 示例分析\n以之前的结构体为例：\nstruct Example &#123;    char a;    // 1字节    int b;     // 4字节    short c;   // 2字节&#125;;\n假设系统的默认对齐规则如下：\n\n\nchar：1字节对齐\n\n\nint：4字节对齐\n\n\nshort：2字节对齐\n\n\n 3.1 成员变量对齐\n\n\nchar a：\n\n\n起始地址：0\n\n\n占用1字节，对齐要求是1字节对齐，因此不需要填充。\n\n\n\n\nint b：\n\n\n起始地址：4（下一个4字节对齐的地址）\n\n\n占用4字节，对齐要求是4字节对齐。\n\n\n在char a和int b之间插入3个填充字节。\n\n\n\n\nshort c：\n\n\n起始地址：8（下一个2字节对齐的地址）\n\n\n占用2字节，对齐要求是2字节对齐。\n\n\n\n\n 3.2 结构体整体对齐\n\n\n结构体的总大小：1（char）+ 3（填充）+ 4（int）+ 2（short）= 10 字节。\n\n\n结构体中最大的成员变量是int，对齐要求是4字节。\n\n\n因此，结构体的总大小必须是4的倍数。\n\n\n在结构体的末尾插入2个填充字节，使得总大小为12字节。\n\n\n最终，结构体在内存中的布局如下：\n[[C语言指针系列图解.excalidraw]]\n\n\n\n地址\n数据\n说明\n\n\n\n\n0\nchar a\n成员变量\n\n\n1\n填充字节\n对齐int b\n\n\n2\n填充字节\n对齐int b\n\n\n3\n填充字节\n对齐int b\n\n\n4\nint b\n成员变量\n\n\n8\nshort c\n成员变量\n\n\n10\n填充字节\n对齐结构体\n\n\n11\n填充字节\n对齐结构体\n\n\n\n结构体的总大小为12字节。\n值得注意的是, 改变结构体成员变量的顺序, 结构体大小也会随之改变\n//该结构体占据12字节typedef struct &#123;    char a;    int b;    short c;&#125; Test;//该结构体占据8字节typedef struct &#123;    char a;    short c;    int b;&#125; Test;\n\n 4. 修改对齐方式\nC语言允许通过编译器的特定指令或属性来修改结构体的对齐方式。例如，在GCC编译器中，可以使用__attribute__((packed))来禁用填充字节：\n#include &lt;stdio.h&gt;//尝试把attribute__((packed))删除，看看输出结果typedef struct &#123;    char a;    int b;    short c;&#125; __attribute__((packed)) Test;int main(void)&#123;    Test test;    test.a = 0x12;    test.b = 0x12345678;    test.c = 0x1234;    char *ptr = (char *)&amp;test;       for(int i = 0; i &lt; sizeof(Test); i++)    &#123;        printf(&quot;%02x\\n&quot;, *(ptr + i));    &#125;&#125;\n在这种情况下，结构体的总大小为7字节，成员变量之间没有填充字节。\n \n 5. 对齐方式的意义\n\n\n提高访问效率：\n\n\n对齐的内存访问通常比非对齐访问更快，因为硬件对对齐的内存访问进行了优化。\n\n\n非对齐访问可能会导致额外的内存读取操作，降低性能。\n\n\n\n\n跨平台兼容性：\n\n不同的硬件平台可能有不同的对齐要求。通过明确指定对齐方式，可以确保结构体在不同平台上具有一致的内存布局。\n\n\n\n节省空间：\n\n在某些情况下，禁用对齐（如使用packed属性）可以节省内存空间，但这可能会牺牲访问效率。\n\n\n\n\n 6. 总结\nC语言结构体的存储方式是按照成员变量的声明顺序依次存储的，但实际的内存布局会受到对齐规则的影响。对齐规则确保每个成员变量的地址是其自身大小的整数倍，并且结构体的总大小是其最大成员变量对齐要求的整数倍。通过理解结构体的对齐方式，可以更好地优化内存使用和提高程序性能。\n了解了结构体的存储方式和对齐方式, 可以使用指针自增的方式访问结构体, 偏移合适的大小, 避开填充字节获取有效的信息, 或者直接禁用填充字节.\n不过, 并不推荐使用指针自增这种方式访问, 指针类型是固定的, 取出来的数据也是按照指针类型取出, 但结构体中的数据却不全是同一类型, 用这种方法取数非常麻烦. 直接使用指针名 + -&gt;运算符, 简单且直观.\n 4.3 数组和结构体相互转换\n禁用填充字节的结构体与数组直接可以直接相互转化, 不会出现问题.\n#include &lt;stdio.h&gt;typedef struct &#123;    char a;    int b;&#125;//解除注释看一看// __attribute__((packed))Test;int main(void)&#123;    char arr[5]=&#123;0x12,0x12,0x34,0x56,0x78&#125;;    Test* ptr_test=(Test*)arr;    printf(&quot;%x\\n&quot;,ptr_test-&gt;a);    printf(&quot;%x\\n&quot;,ptr_test-&gt;b);&#125;\n对于结构体和数组相互转化, 试看如下的应用\n如下是某品牌激光雷达开发手册, 其中3.1节 数据包格式中描述了雷达向控制器(计算机)传输的数据包的格式, 并给出了数据结构定义.\n如何将原始数据包转化为结构体?\n首先使用数组作为接收缓冲区, 数组大小等于两个数据包大小, 数据类型为uint8_t, 也就是char\n#define PACKET_SIZE 47typedef struct &#123;    uint8_t header;//数据包头,固定为0x54    uint8_t packet_length;//数据包长度,固定为0x2c    uint16_t speed;//雷达旋转速度    uint16_t start_angle;//该数据包的起始角度    LidarPointStructDef point[POINT_PER_PACKET];//激光点数据,每个数据包包含12个激光点    uint16_t end_angle;//该数据包的结束角度    uint16_t timestamp;//时间戳    uint8_t crc8;//CRC校验码&#125; __attribute__((packed)) LidarPacket;//接收数据包的函数void Recieve_LidarPacket(uint8_t * rx_buffer)&#123;//具体实现不必关心&#125;uint8_t rx_buffer[PACKET_SIZE];Recieve_LidarPacket(rx_buffer);//调用接收函数接收数据包,调用完成后rx_buffer就装了一个数据包长度的数据了,而且第一个数组元素就是数据包头LidarPacket* pLidarPacketStruct=(LidarPacket*)rx_buffer;//将uint8*类型的数组直接转化为LidarPacket*,由于LidarPacket被定义为禁用填充字节的模式,后续的所有元素都会按照顺序一一对应printf(&quot;0x%2x&quot;,pLidarPacketStruct-&gt;header);//可以直接使用指针访问对应元素,不会出现偏差\n事实上, 对于任何拥有严格结构限制的数据, 禁用填充字节使用结构体接收, 是一种常见的应用. 如接收通讯协议数据, 接收特定文件格式. 同时也保证代码的可移植性,节省内存空间. 相应的劣势是访问结构体的时间会增加.\n 5. 函数指针\n待续…\n","categories":["编程语言","c/c++"],"tags":["C语言","指针"]},{"title":"单片机启动流程介绍","url":"/2025/08/31/%E5%8D%95%E7%89%87%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/","content":" 1. 硬件读取BOOT引脚\n​BOOT0 和 BOOT1 的作用​\nBOOT0 和 BOOT1 引脚的不同组合决定了芯片启动时映射到 0x00000000 的存储器区域。具体组合如下：\n\n\n\nBOOT1\nBOOT0\n启动模式\n映射到 0x00000000 的存储器区域\n物理介质类型\n\n\n\n\nx\n0\n主闪存（Main Flash）启动\n主闪存起始地址 0x08000000\n内部NOR Flash\n\n\n0\n1\n系统存储器（System Memory）启动\n系统存储器起始地址 0x1FFF0000\n内部NOR Flash\n\n\n1\n1\n内置 SRAM 启动\n内置 SRAM 起始地址 0x20000000\nSRAM\n\n\n\n​关键特性对比​：\n\n​主闪存​：可读写NOR Flash，存储用户程序\n​系统存储器​：只读NOR Flash，存储厂商Bootloader，也称bootROM\n​内置SRAM​：易失性存储器，需预先加载代码\n\n​硬件启动逻辑的作用​：\n\n仅根据BOOT引脚电平进行存储器映射\n不区分Bootloader和用户程序\n映射完成后立即从0x00000000开始执行\n\n 2. MCU总线与存储器架构\n 2.1 Cortex-M存储器映射\ngraph LR    0x00000000-0x1FFFFFFF[Code区域] --&gt; ICode[I-Code总线]    0x00000000-0x1FFFFFFF[Code区域] --&gt; DCode[D-Code总线]    0x20000000-0x3FFFFFFF[SRAM区域] --&gt; System[System总线]    0x40000000-0x5FFFFFFF[外设区域] --&gt; System[System总线]    0xE0000000-0xFFFFFFFF[内核外设] --&gt; PPB[PPB总线]\n 2.2 总线架构详解\n\n\n​I-Code总线​：\n\n专用于指令取指和向量表读取\n支持突发传输和预取优化\n只读访问，不可写\n\n\n\n​D-Code总线​：\n\n用于常量数据访问（.const段）\n支持读写操作\n与I-Code并行工作提高效率\n\n\n\n​System总线​：\n\n处理SRAM和外设访问\n支持所有读写操作\n带宽低于I/D-Code\n\n\n\n 2.3 存储器访问特性\n// 不同存储区域的访问方式void *code_ptr = (void*)0x08001234; // I-Code访问（指令）const uint32_t *data_ptr = (uint32_t*)0x08005678; // D-Code访问（常量）volatile uint32_t *reg_ptr = (uint32_t*)0x40021000; // System访问（外设）\n 3. 三种不同启动模式的区别\n 3.1 启动中的关键组件\n 中断向量表\n​Cortex-M架构规范​：\ntypedef struct &#123;    uint32_t initial_sp;    // 初始堆栈指针    void (*reset_handler)(void); // 复位处理函数    void (*nmi_handler)(void);   // NMI处理函数    // ...其他中断向量&#125; VectorTable;\n Bootloader\n​功能分类​：\n\n\n​内置Bootloader​（系统存储器中）：\n\n支持USART/USB/CAN等接口的固件更新\n提供有限的硬件初始化\n\n\n\n​自定义Bootloader​（用户Flash中）：\n\n支持OTA升级\n可包含加密验证功能\n提供更完整的硬件初始化\n\n\n\n Startup File\n​典型启动文件流程​（startup_stm32fxxx.s）：\nReset_Handler:    LDR     R0, =__initial_sp    ; 再次初始化SP    MSR     MSP, R0    BL      SystemInit           ; 系统时钟初始化    BL      __main               ; C库初始化    B       main                ; 跳转到用户程序\n 3.2 启动模式详细流程\n 从主闪存启动（BOOT0=0）\n​执行流程图​：\nsequenceDiagram    硬件-&gt;&gt;+主闪存: 映射0x08000000→0x00000000    硬件-&gt;&gt;+主闪存: 读取向量表    硬件-&gt;&gt;CPU: 初始化MSP并跳转    CPU-&gt;&gt;Startup: 执行Reset_Handler    Startup-&gt;&gt;SystemInit: 时钟配置    Startup-&gt;&gt;__main: C库初始化    __main-&gt;&gt;main: 进入用户程序\n 从系统存储器启动（BOOT0=1, BOOT1=0）\n​特殊考虑​：\n\n\n内置Bootloader通常不初始化所有外设\n\n\n跳转到用户程序前需手动配置：\n  void jump_to_app(uint32_t app_addr) &#123;    __disable_irq();    SCB-&gt;VTOR = app_addr;    __set_MSP(*(uint32_t*)app_addr);    ((void(*)(void))*(uint32_t*)(app_addr+4))();&#125;\n\n\n 从内置SRAM启动（BOOT0=1, BOOT1=1）\n​代码加载方式​：\n\n\n通过调试器直接写入\n\n\n通过其他Bootloader加载：\n void load_to_sram(uint8_t *src, uint32_t size) &#123;    memcpy((void*)0x20000000, src, size);    __DSB(); // 确保数据同步&#125;\n\n\n 从外部NAND Flash/SD卡启动\n这种方式比较特殊，实际上还是一般还是从系统存储器（bootROM）启动，这里存储了bootloader，将bootloader的关键部分（至少要到初始化外部flash的部分）载入\n​特殊启动流程​：\nsequenceDiagram    ROM Code-&gt;&gt;NAND Flash: 1.初始化NAND控制器    ROM Code-&gt;&gt;SRAM: 2.加载前4KB代码    SRAM-&gt;&gt;SRAM: 3.执行初始引导程序    SRAM-&gt;&gt;DDR: 4.初始化内存控制器    SRAM-&gt;&gt;NAND Flash: 5.加载完整程序    SRAM-&gt;&gt;DDR: 6.复制到DDR内存    SRAM-&gt;&gt;DDR: 7.跳转到主程序\n​关键限制​：\n\nNAND Flash无法直接执行代码(XIP)\n必须通过SRAM中转加载\n需要专用控制器处理坏块和ECC\n\n 3.3 启动模式对比总结\n\n\n\n特性\n主闪存启动\n系统存储器启动\nSRAM启动\n外部NAND启动\n\n\n\n\n​执行位置​\nNOR Flash\nNOR Flash\nSRAM\nDDR/SRAM\n\n\n​是否需要加载​\n否\n否\n是\n是\n\n\n​XIP支持​\n是\n是\n是\n否\n\n\n​典型用途​\n正常运行模式\n固件更新模式\n调试/特殊模式\n大容量系统\n\n\n\n 4. Cortex-M与Cortex-A启动对比\n​关键差异​：\n\n\n\n特性\nCortex-M\nCortex-A\n\n\n\n\n​向量表位置​\n固定地址\n由OS动态设置\n\n\n​初始化主体​\nStartup File\nBootloader\n\n\n​典型Bootloader​\n简单（内置/自定义）\n复杂（如U-Boot）\n\n\n​多阶段启动​\n可选\n必需\n\n\n​MMU使用​\n无/简单MPU\n必需\n\n\n\n 5. 常见问题解答\n​Q1：中断向量表为何要两次初始化SP？​​\n\n硬件初始化：确保最早期的函数调用可用\n软件初始化：允许动态调整堆栈位置和大小\n\n​Q2：NOR Flash和NAND Flash在启动中的本质区别？​​\n// NOR Flash执行（直接访问）void (*nor_func)() = (void(*)())0x08001234;nor_func();// NAND Flash执行（需加载）memcpy(0x20001000, nand_data, size);void (*nand_func)() = (void(*)())0x20001000;nand_func();\n​Q3：总线矩阵如何提升性能？​​\ngraph TB    CPU --&gt;|I-Code| Flash[指令读取]    CPU --&gt;|D-Code| Flash[常量读取]    Flash --&gt;|并行传输| CPU\n 6. 补充技术细节\n​Flash加速技术​：\n\nSTM32 ART Accelerator：\n\n实现等效0等待周期执行\n128位预取缓冲机制\n\n\n\n​安全启动考虑​：\ngraph TD    Bootloader --&gt;|验证签名| Firmware    Firmware --&gt;|加密存储| Flash    Flash --&gt;|安全加载| SRAM\n 7. 参考资料更新\n\nSTM32Cube编程手册\nARM Cortex-M权威指南\nU-Boot官方文档\nNAND Flash启动技术白皮书\n[[ARM Cortex-M3 M4单片机启动流程]]\n配置系统从SRAM启动\nstm32启动方式汇总\n\n","categories":["嵌入式","单片机"],"tags":["单片机","BOOT"]},{"title":"keil新建stm32单片机工程","url":"/2025/09/10/keil%E6%96%B0%E5%BB%BAstm32%E5%8D%95%E7%89%87%E6%9C%BA%E5%B7%A5%E7%A8%8B/","content":" 新建stm32工程\n 工程分类\n标准库和HAL库\n1.使用标准库需要在ST官网下载相关库\n官方地址\n2.使用HAL库可以下载STM32cubeMX直接生成工程模板，需要在其中选择芯片型号，配置时钟源等基本配置。cubemx不止可以生成keil工程，还可以生成其他IDE的工程。\n 实际操作（标准库）\n 1.新建工程\n选择合适的存放位置，路径上不要有中文（keil其实支持中文路径，但最好养成习惯），其他略\n 2.导入库函数\n库函数类型的说明：\n\n\n启动文件（startup）：.s结尾，以汇编语言编写，例如startup_stm32f4xx.s。根据芯片类型不同选择不同的文件，一个工程里只需要一个，是程序的开始的位置。\n\n\n系统初始化文件（system_stm32f4xx.c）：系统时钟初始化配置文件。\n\n\n内核寄存器配置文件（core_xx.h,core_xx.c）：根据不同的内核选择不同的文件，f10x系列单片机有core_cm3.c,core_cm3.h两个文件，而f4xx系列只有core_cm4.h\n\n\n芯片头文件（stm32f4xx.h）：其中是很多宏定义，用来定义芯片寄存器、外设等信息。\n\n\n库配置文件（stm32f4xx_conf.h 或 stm32f4xx_hal_conf.h）：各种头文件的包含关系，根据宏定义决定启用/禁用库相应的模块。\n\n\n中断函数文件（stm32f4xx_it.h,stm32f4xx_it.c）：存放中断函数的文件\n\n\n外设驱动文件(stm32f4xx_adc)：命名规则：芯片型号_外设 其中包含相应的外设的功能函数，使用这些函数，通过配置结构体即可控制相应的外设，而不必直接与寄存器打交道。根据具体需求添加，如 stm32f4xx_rcc.c、stm32f4xx_gpio.c。\n\n\n主程序文件（main.c）：用户应用代码文件。\n\n\n创建文件夹，将所需的文件放在相应的文件夹中，方便管理，这一步可以根据自己的习惯分类\n主要分为三类:\n\n\nStart：系统初始化相关的文件，例如core_cm3.c/.h,startup_stm32xxx.s,system_stm32fxx.c/.h,\n\n\nLibrary:外设驱动函数和内核库函数，例如：misc.c/h,stm32f4xx_rcc.c,stm32f4xx_gpio.c\n\n\nUser:用户新建或常用的函数，例如：main.c,stm32f4xx.h\n\n\nNote\n使用vscode创建工程, 成功包含了头文件但是右键函数等无法跳转可以尝试尝试重新打开工程\n 3.相关配置\n1.有些宏需要配置到keil中，通过查看stm32f4xx.h(不同型号单片机该文件名不同，一般都是根据芯片类型选择)，可以看到其中的宏定义。\n#ifdef USE_STDPERIPH_DRIVER  #include &quot;stm32f4xx_conf.h&quot;#endif /* USE_STDPERIPH_DRIVER */\n点击“魔术棒”按钮,选择&quot;c/c++&quot;,在“define”栏中填入上述宏定义USE_STDPERIPH_DRIVER\n不论型号，几乎所有的STM32项目该宏都是通用的，所以这一步可以看作固定步骤。\n2.可以尝试编译，发现报错Please select first the target STM32F4xx device used in your application (in stm32f4xx.h file)\n原因是在stm32f4xx.h中定义了f4xx系列单片机的各种寄存器，f4xx系列也有很多子系列单片机，其中不同型号的单片机的寄存器配置也不相同，因此需要一个宏来确认你所使用的单片机的具体型号型号，根据报错来确定位置，找到对应芯片的宏。\n#if !defined(STM32F40_41xxx) &amp;&amp; !defined(STM32F427_437xx) &amp;&amp; !defined(STM32F429_439xx) &amp;&amp; !defined(STM32F401xx) &amp;&amp; !defined(STM32F410xx) &amp;&amp; \\    !defined(STM32F411xE) &amp;&amp; !defined(STM32F412xG) &amp;&amp; !defined(STM32F413_423xx) &amp;&amp; !defined(STM32F446xx) &amp;&amp; !defined(STM32F469_479xx) #error &quot;Please select first the target STM32F4xx device used in your application (in stm32f4xx.h file)&quot;#endif /* STM32F40_41xxx &amp;&amp; STM32F427_437xx &amp;&amp; STM32F429_439xx &amp;&amp; STM32F401xx &amp;&amp; STM32F410xx &amp;&amp; STM32F411xE &amp;&amp; STM32F412xG &amp;&amp; STM32F413_23xx &amp;&amp; STM32F446xx &amp;&amp; STM32F469_479xx */\n例如，点击“魔术棒”按钮,选择&quot;c/c++&quot;,在“define”栏中填写宏定义STM32F429_439xx，代表该型号被选定，其所拥有的特定寄存器可用。\n3.使用微库MicroLIB\n选择“魔术棒”按钮-&gt;target选项-&gt;Use MicroLIB\nTarget中选中微库“ Use MicroLib”，为的是在日后编写串口驱动的时候可以使用printf函数。而且有些应用中如果用了STM32的浮点运算单元FPU， 一定要同时开微库，不然有时会出现各种奇怪的现象。FPU的开关选项在微库配置选项下方的“Use Single Precision”中，默认是开的。\n4.包含头文件\n在C/C++选项卡中添加处理宏及编译器编译的时候查找的头文件路径。\n\n“Include Paths ”这里添加的是头文件的路径，如果编译的时候提示说找不到头文件，一般就是这里配置出了问题。你把头文件放到了哪个文件夹， 就把该文件夹添加到这里即可。(请使用图中的方法用文件浏览器去添加路径，不要直接手打路径，容易出错)\n5.生成二进制文件\n在Output选项卡中把输出文件夹定位到我们工程目录下的“output”文件夹， 如果想在编译的过程中生成hex文件，那么那Create HEX File选项勾上。\nhex文件用于烧录\n\n 4.编译验证\n上述配置完成后尝试编译，看看会遇到什么报错，依次解决。\n可能的报错\n\n\n宏重复定义\n参考网络文章,可能是官方库函数的bug，出现了同名的宏定义，于是产生冲突，把相应的宏注释掉即可\n\n\nstm32f4xx_fsmc.c文件报错(f429型号报错)\n参考网络文章：https://bbs.eeworld.com.cn/thread-427197-1-1.html\n原因是不同型号的芯片功能不同，需要使用宏来区分，f429使用的fmc外设，没有fsmc外设，与其fsmc相关的宏定义会报错。\n解决方法，右键单击该文件，选择不加入编译。或者可以直接将文件从工程中移除\n\n\nstm32f4xx_fmc.c文件报错\n原因同上，解决方法相同\n\n\nSTM32F429比较特殊，它有用FMC外设代替了FSMC外设的功能，所以它的库文件与其它型号的芯片不一样，在添加外设文件时， stm32f4xx_fmc.c和stm32f4xx_fsmc.c文件只能存在一个，而且我们的STM32F429芯片必须用fmc文件。如果我们把外设库的所有文件都添加进工程， 也可以使用下面的方法，设置文件不加入编译，这样也不会导致编译问题。这种设置在开发时也很常用，暂时不把文件加进编译，方便调试。\n\n链接错误\n\n..\\Output\\STM32F429_439xx-DEMO.axf: Error: L6218E: Undefined symbol TimingDelay_Decrement (referred from stm32f4xx_it.o).\n原因在于TimingDelay_Decrement函数出现异常\n找到stm32f4xx_it.c 这个文件里的如下函数\n  void SysTick_Handler(void)&#123;  TimingDelay_Decrement（）；&#125;\n去删掉或者注释掉TimingDelay_Decrement（）；这个函数应该就可以了。\n5. 链接错误\n链接报错\n\nstart linking …\n\n“d:/work/CO2/CO2_project/build/Debug/CO2_project.sct”, line 7 (column 8): Error: L6235E: More than one section matches selector - cannot all be FIRST/LAST.\nNot enough information to list image symbols.\nNot enough information to list the image map.\nFinished: 2 information, 0 warning and 1 error messages.\n以上报错的大致含义是: 在工程的链接脚本CO2_project.sct中有不止一个FIRST/LAST section\n可能的原因是包含了不止一个启动文件, 启动文件时以汇编语言编写的, 文件名形如startup_stm32f429_439xx.s，只在文件中保留一个与使用单片机型号相同的文件即可，其他从文件中移除。\n","categories":["嵌入式","单片机","STM32"],"tags":["stm32","keil"]}]